
use std::io::Cursor;

use machine::{Chip8, RuntimeError};

fn run_program(chip8: &mut Chip8, program: &[u8]) {
    let cursor = Cursor::new(program);
    chip8.load_program(cursor);

    for _ in 0..program.len() / 2 {
        chip8.cycle([false; 16]);
    }
}

#[test]
fn skipping_instructions() {
    let mut chip8 = Chip8::new();

    let program = [
        // set vF to 0
        0x6A, 0x00,
        0x6B, 0x00,

        // set v0 and v1 to 255
        0x60, 0xFF,
        0x61, 0xFF,

        // skip if they're equal
        0x50, 0x10,
        0x6A, 0x01,
        
        // skip if they're not equal
        0x90, 0x10,
        0x6B, 0x01,
    ];

    run_program(&mut chip8, &program[..]).unwrap();

    assert_eq!(chip8.regs[0xA], 0x0);
    assert_eq!(chip8.regs[0xB], 0x1);
}

#[test]
fn dump_and_load_regs() {
    let mut chip8 = Chip8::new();

    let program = [
        // Set regs
        0x60, 0x00,
        0x61, 0x01,
        0x62, 0x02,
        0x63, 0x03,
        0x64, 0x04,
        0x65, 0x05,
        0x66, 0x06,
        0x67, 0x07,
        0x68, 0x08,
        0x69, 0x09,
        0x6A, 0x0A,
        0x6B, 0x0B,
        0x6C, 0x0C,
        0x6D, 0x0D,
        0x6E, 0x0E,
        0x6F, 0x0F,

        // Set memory address, dump regs
        0xAD, 0x00,
        0xFF, 0x55,

        0x60, 0x00,
        0x61, 0x00,
        0x62, 0x00,
        0x63, 0x00,
        0x64, 0x00,
        0x65, 0x00,
        0x66, 0x00,
        0x67, 0x00,
        0x68, 0x00,
        0x69, 0x00,
        0x6A, 0x00,
        0x6B, 0x00,
        0x6C, 0x00,
        0x6D, 0x00,
        0x6E, 0x00,
        0x6F, 0x00,

        // Now restore
        0xFF, 0x65,
    ];

    run_program(&mut chip8, &program[..]);

    for i in 0..15 {
        assert_eq!(chip8.regs[i], i as u8);
    }
}
